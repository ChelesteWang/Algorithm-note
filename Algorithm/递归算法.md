## 递归算法

递归算法作为所有算法中最基础最必不可少的一部分至关重要，很多时候大家并不能正确的认识递归算法的思路与理解。
无论是二叉树还是各种搜索算法都离不开递归算法。

递归本质: 将复杂的问题转化为简单的问题,再对简单的问题求解，从而推出复杂问题的答案
每一个函数处理完成一个功能

递归算法的核心可以分成四部分

1. 函数终止条件
2. 函数要处理什么
3. 函数相关变量
4. 问题的递推方程

以最简单的求解斐波那契数列为例

leetcode 70. 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```js
function Fibonacci(x) {
    if (x == 1) { return 1 }
    if (x == 2) { return 2 }
    return Fibonacci(x - 1) + Fibonacci(x - 2)
}
```
根据题意可以分析出以上 Fibonacci 算法的四部分分别对应是什么

1. 终止条件 x=1 , Fn=1 以及 x=2 Fn=2 
2. 函数要处理什么 返回 Fn(X)
3. 函数相关变量 本题只有 x
4. 问题的递归方程: F(x) = F(x-1) + F(x-2) 

相信上面的代码大家都可以闭眼默写出来,但是本算法面对 n > 30 以上遍束手无策了
原因是在递归的过程中，Fn 1,2,3,4,5,6 被计算了过多次, 于是算法运行便超时了, 那我们不妨尝试让重复计算尽可能的去减少一下。

优化版

```js
function Fibonacci(x) {
    let memo = []
    function fun(x) {
        if (x == 1) { memo[1] = 1 }
        if (x == 2) { memo[2] = 2 }
        if (!memo[x]) {
            memo[x] = Fibonacci(x - 1) + Fibonacci(x - 2)
        }
        return memo[x]
    }
    return fun(x)
}
```
根据代码可以分析出以上 Fibonacci memo优化算法的四部分分别对应是什么

1. 终止条件 x=1 , memo[1]=1 以及 x=2 memo[2]=2 
2. 函数要处理什么 memo[x]=Fn(x) 
3. 函数相关变量 本题只有 x
4. 问题的递归方程: F(x) = F(x-1) + F(x-2) 
    吗         

当然如果还要优化就需要使用动态规划了，具体优化我们按下不表，到动态规划部分再聊

我们看下一个例子

运动会开了N天，一共发出金牌M枚。第一天发金牌1枚加剩下的七分之一枚，第二天发金牌2枚加剩下的七分之一枚，第3天发金牌3枚加剩下的七分之一枚，以后每天都照此办理。到了第N天刚好还有金牌N枚，到此金牌全部发完。编程求N和M。


根据题意可以分析出以上算法的四部分分别对应是什么

1. 终止条件 
2. 函数要处理什么 



  
3. 函数相关变量 本题涉及到 N , M 
4. 问题的递归方程: 


链表

二叉树

栈